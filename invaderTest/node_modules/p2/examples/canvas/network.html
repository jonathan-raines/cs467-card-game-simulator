<!DOCTYPE html>
<html lang="en">
  <head>
    <title>p2.js network example</title>
    <meta charset="utf-8">
    <script src="../../build/p2.js"></script>
    <style type="text/css">
    canvas {
      border: 1px solid silver;
    }
    </style>
  </head>
  <body>

    <!-- The canvas, where we draw stuff -->
    <canvas width="200" height="200" id="canvasClient1"></canvas>
    <canvas width="200" height="200" id="canvasServer"></canvas>
    <canvas width="200" height="200" id="canvasClient2"></canvas>

    <script>

      var client1, server, client2, zoom = 10, lineWidth = 0.1, delay = 0.2, maxPrevStates = 1000, maxOffset = 0.5;

      // Base class
      function Node(){
        this.incomingMessages = [];
      }
      Node.prototype.send = function(to, message){
        message.time = time();
        to.incomingMessages.push(message);
      };
      Node.prototype.recieve = function(){
        var t = time();
        for (var i = 0; i < this.incomingMessages.length; i++) {
          var message = this.incomingMessages[i];
          if(message.time <= t - delay){
            this.incomingMessages.splice(i, 1);
            return message;
          }
        }
      };

      function Client(canvasId, server, options){
        options = options || {};
        Node.call(this, server);

        this.server = server;

        // Init canvas
        var canvas = this.canvas = document.getElementById(canvasId);
        var ctx = this.ctx = canvas.getContext("2d");
        ctx.lineWidth = lineWidth;

        var world = this.world = new p2.World({ gravity:[0,0] });

        // Add a circle
        var circleShape = new p2.Circle(1);
        var circleBody = this.playerBody = new p2.Body({ mass: 1, position: options.position });
        circleBody.damping = 0;
        circleBody.addShape(circleShape);
        world.addBody(circleBody);
        this.inputState = {
          x: 0,
          y: 0
        };

        this.prevStates = [];
        var that = this;
        world.on('postStep', function(){
          that.playerBody.force[0] += that.inputState.x * 10;
          that.playerBody.force[1] += that.inputState.y * 10;
          that.prevStates.push({
            time: time(),
            x: that.playerBody.position[0],
            y: that.playerBody.position[1],
            vx: that.playerBody.velocity[0],
            vy: that.playerBody.velocity[1]
          });
          if(that.prevStates.length > maxPrevStates)
            that.prevStates.shift();
        });

        this.otherPlayers = {}; // id: array

        server.connectClient(this);
      }
      Client.prototype = Object.create(Node.prototype);
      Client.prototype.constructor = Client;

      Client.prototype.update = function(){
        // Get messages about other players
        var message;
        while(message = this.recieve()){
          if(message.clientId === this.id){
            // Own player. Check if it diffs with history data and let the server be authorative if it differs

            // Get prev data from that time
            var state = this.prevStates[0]; // oldest
            if(!state) continue;
            var i = 0;
            while(state && state.time < message.time){
              state = this.prevStates[++i];
            }
            if(state){
              if(Math.abs(state.x - message.x) > maxOffset || Math.abs(state.y - message.y) > maxOffset){
                console.log('reset')

                // this.prevStates.length = 0;
                this.playerBody.position[0] = message.x;
                this.playerBody.position[1] = message.y;
                this.playerBody.velocity[0] = message.vx;
                this.playerBody.velocity[1] = message.vy;

              } else {

                this.playerBody.position[0] += (state.x - message.x) * 0.3;
                this.playerBody.position[1] += (state.y - message.  y) * 0.3;
                this.playerBody.velocity[0] += (state.vx - message.vx) * 0.3;
                this.playerBody.velocity[1] += (state.vy - message.vy) * 0.3;
              }
            }

          } else {
            // Other player. Save its state.
            if(!this.otherPlayers[message.clientId])
              this.otherPlayers[message.clientId] = [];

            var history = this.otherPlayers[message.clientId];
            history.push({
              x: message.x,
              y: message.y
            });

            if(history.length > 2){
              history.shift();
            }
          }
        }

        this.world.step(1 / 60);
      };

      Client.prototype.sendState = function(){
        this.send(this.server, {
          clientId: this.id,
          x: this.inputState.x,
          y: this.inputState.y
        });
      };

      Client.prototype.connectKeyboard = function(){
        var that = this;
        document.addEventListener('keydown', function(evt){
          var state = that.inputState;
          var oldState = JSON.parse(JSON.stringify(that.inputState));
          switch(evt.keyCode){
          case 38: // Up
            state.y = 1;
            break;
          case 37: // left
            state.x = -1;
            break;
          case 40: // down
            state.y = -1;
            break;
          case 39: // right
            state.x = 1;
            break;
          }
          for(var key in state){
            if(state[key] !== oldState[key]){
              that.sendState();
              break;
            }
          }
        });
        document.addEventListener('keyup', function(evt){
          var state = that.inputState;
          var oldState = JSON.parse(JSON.stringify(that.inputState));
          switch(evt.keyCode){
          case 38: // Up
          case 40: // down
            state.y = 0;
            break;
          case 39: // right
          case 37: // left
            state.x = 0;
            break;
          }
          for(var key in state){
            if(state[key] !== oldState[key]){
              that.sendState();
              break;
            }
          }
        });
      };

      Client.prototype.render = function(){
        var ctx = this.ctx;
        var circleBody = this.playerBody;
        var circleShape = circleBody.shapes[0];
        var radius = circleShape.radius;

        ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        ctx.save();
        ctx.translate(this.canvas.width/2, this.canvas.height/2);
        ctx.scale(zoom, -zoom);

        // Draw the circle at the interpolated position
        ctx.beginPath();
        ctx.arc(
          circleBody.position[0],
          circleBody.position[1],
          radius,
          0,
          2 * Math.PI
        );
        ctx.stroke();

        // Other players
        for(var clientId in this.otherPlayers){
          var state = this.otherPlayers[clientId][0];
          if(!state) continue;

          ctx.beginPath();
          ctx.arc(
            state.x,
            state.y,
            radius,
            0,
            2 * Math.PI
          );
          ctx.stroke();
        }

        ctx.restore();
      };

      function Server(canvasId){
        Node.call(this, server);
        var that = this;

        this.clients = [];

        // Init canvas
        var canvas = this.canvas = document.getElementById(canvasId);
        var ctx = this.ctx = canvas.getContext("2d");
        ctx.lineWidth = lineWidth;

        var world = this.world = new p2.World({ gravity:[0,0] });

        this.inputState = {
          x: 0,
          y: 0
        };

        this.prevStates = [];
        world.on('postStep', function(){
          for (var i = 0; i < that.clients.length; i++) {
            var client = that.clients[i];
            client.body.force[0] += client.inputState.x * 10;
            client.body.force[1] += client.inputState.y * 10;
          }

          // Broadcast current positions
          that.broadcastPositions();
        });

      }
      Server.prototype = Object.create(Node.prototype);
      Server.prototype.constructor = Server;

      Server.prototype.update = function(){
        var message;

        while(message = this.recieve()){
          // Find client
          for (var i = 0; i < this.clients.length; i++) {
            var client = this.clients[i];
            if(client.id === message.clientId){
              client.inputState.x = message.x;
              client.inputState.y = message.y;
            }
          }
        }

        this.world.step(1 / 60);
      };

      Server.prototype.broadcastPositions = function(){
        for (var i = 0; i < this.clients.length; i++) {
          var clientA = this.clients[i];

          for (var j = 0; j < this.clients.length; j++) {
            var clientB = this.clients[j];

            this.send(clientA.node,{
              clientId: clientB.id,
              x: clientB.body.position[0],
              y: clientB.body.position[1],
              vx: clientB.body.velocity[0],
              vy: clientB.body.velocity[1]
            });
          }
        }
      };

      Server.prototype.connectClient = function(client){
        // Add a circle
        var circleShape = new p2.Circle(1);
        var circleBody = new p2.Body({ mass:1, position: client.playerBody.position });
        circleBody.damping = 0;
        circleBody.addShape(circleShape);
        this.world.addBody(circleBody);

        client.id = this.clients.length;

        this.clients.push({
          id: client.id,
          node: client,
          inputState: {
            x:0,
            y:0
          },
          body:circleBody
        });
      };

      Server.prototype.render = function(){

        var ctx = this.ctx;
        ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        ctx.save();
        ctx.translate(this.canvas.width/2, this.canvas.height/2);
        ctx.scale(zoom, -zoom);

        for (var i = 0; i < this.clients.length; i++) {
          var client = this.clients[i];

          var circleBody = client.body;
          var circleShape = circleBody.shapes[0];
          var radius = circleShape.radius;

          ctx.beginPath();
          ctx.arc(
            circleBody.position[0],
            circleBody.position[1],
            radius,
            0,
            2 * Math.PI
          );
          ctx.stroke();
        }

        ctx.restore();
      };

      function init(){
        server = new Server('canvasServer');
        client1 = new Client('canvasClient1', server, { position: [-2,0] });
        client2 = new Client('canvasClient2', server, { position: [2,0] });
        client1.connectKeyboard();
      }

      function render(){
        client1.update();
        server.update();
        client2.update();

        client1.render();
        server.render();
        client2.render();
      }

      var lastCallTime = time();

      // Animation loop
      function animate(t){
        t = t || 0;
        requestAnimationFrame(animate);
        render();
      }

      // Get current time, in seconds.
      function time(){
        return new Date().getTime() / 1000;
      }

      init();
      animate();

    </script>

  </body>
</html>
